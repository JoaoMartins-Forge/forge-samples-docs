"use strict";(self.webpackChunkforge_samples_docs=self.webpackChunkforge_samples_docs||[]).push([[33],{3905:function(e,n,t){t.d(n,{Zo:function(){return p},kt:function(){return m}});var a=t(7294);function i(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){i(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,i=function(e,n){if(null==e)return{};var t,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(i[t]=e[t]);return i}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(i[t]=e[t])}return i}var c=a.createContext({}),l=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},p=function(e){var n=l(e.components);return a.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=l(t),m=i,k=d["".concat(c,".").concat(m)]||d[m]||u[m]||r;return t?a.createElement(k,o(o({ref:n},p),{},{components:t})):a.createElement(k,o({ref:n},p))}));function m(e,n){var t=arguments,i=n&&n.mdxType;if("string"==typeof e||i){var r=t.length,o=new Array(r);o[0]=d;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var l=2;l<r;l++)o[l]=t[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},6471:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return p},default:function(){return d}});var a=t(7462),i=t(3366),r=(t(7294),t(3905)),o=["components"],s={sidebar_position:3},c="Data Management",l={unversionedId:"tutorials/simple-viewer/dotnet/data-management",id:"tutorials/simple-viewer/dotnet/data-management",isDocsHomePage:!1,title:"Data Management",description:"Next, let's extend our server so that we can list models, upload them, and also initiate",source:"@site/docs/tutorials/simple-viewer/dotnet/data-management.md",sourceDirName:"tutorials/simple-viewer/dotnet",slug:"/tutorials/simple-viewer/dotnet/data-management",permalink:"/forge-samples-docs/docs/tutorials/simple-viewer/dotnet/data-management",editUrl:"https://github.com/petrbroz/forge-samples-docs/edit/main/website/docs/tutorials/simple-viewer/dotnet/data-management.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Authentication",permalink:"/forge-samples-docs/docs/tutorials/simple-viewer/dotnet/authentication"},next:{title:"Viewer",permalink:"/forge-samples-docs/docs/tutorials/simple-viewer/dotnet/viewer"}},p=[{value:"Preparing a bucket",id:"preparing-a-bucket",children:[]},{value:"Listing models",id:"listing-models",children:[]},{value:"Uploading and translating models",id:"uploading-and-translating-models",children:[]},{value:"Server endpoints",id:"server-endpoints",children:[]},{value:"Try it out",id:"try-it-out",children:[]}],u={toc:p};function d(e){var n=e.components,t=(0,i.Z)(e,o);return(0,r.kt)("wrapper",(0,a.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"data-management"},"Data Management"),(0,r.kt)("p",null,"Next, let's extend our server so that we can list models, upload them, and also initiate\ntheir translation for viewing."),(0,r.kt)("h2",{id:"preparing-a-bucket"},"Preparing a bucket"),(0,r.kt)("p",null,"First, let's make sure that our application has a bucket in the Data Management service\nto store its files in. Typically the bucket would be created just once as part of a provisioning\nstep but in our sample we will implement a helper function that will make sure that the bucket\nis available. Let's update the ",(0,r.kt)("inlineCode",{parentName:"p"},"Models/ForgeService.cs")," file:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Models/ForgeService.cs"',title:'"Models/ForgeService.cs"'},'using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading.Tasks;\nusing Autodesk.Forge;\nusing Autodesk.Forge.Client;\nusing Autodesk.Forge.Model;\n\nnamespace simpleviewer\n{\n    public class Token\n    {\n        public string AccessToken { get; set; }\n        public DateTime ExpiresAt { get; set; }\n    }\n\n    public interface IForgeService\n    {\n        Task<Token> GetAccessToken();\n    }\n\n    public class ForgeService : IForgeService\n    {\n        private readonly string _clientId;\n        private readonly string _clientSecret;\n        private readonly string _bucket;\n        private Token _internalTokenCache;\n        private Token _publicTokenCache;\n\n        public ForgeService(string clientId, string clientSecret, string bucket = null)\n        {\n            _clientId = clientId;\n            _clientSecret = clientSecret;\n            _bucket = string.IsNullOrEmpty(bucket) ? string.Format("{0}-basic-app", _clientId.ToLower()) : bucket;\n        }\n\n        public async Task<Token> GetAccessToken()\n        {\n            return await GetPublicToken();\n        }\n\n        // highlight-start\n        private async Task EnsureBucketExists(string bucketKey)\n        {\n            var token = await GetInternalToken();\n            var api = new BucketsApi();\n            api.Configuration.AccessToken = token.AccessToken;\n            try\n            {\n                await api.GetBucketDetailsAsync(bucketKey);\n            }\n            catch (ApiException e)\n            {\n                if (e.ErrorCode == 404)\n                {\n                    await api.CreateBucketAsync(new PostBucketsPayload(bucketKey, null, PostBucketsPayload.PolicyKeyEnum.Temporary));\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n        }\n        // highlight-end\n\n        private async Task<Token> GetPublicToken()\n        {\n            if (_publicTokenCache == null || _publicTokenCache.ExpiresAt < DateTime.UtcNow)\n            {\n                _publicTokenCache = await GetToken(new Scope[] { Scope.ViewablesRead });\n            }\n            return _publicTokenCache;\n        }\n\n        private async Task<Token> GetInternalToken()\n        {\n            if (_internalTokenCache == null || _internalTokenCache.ExpiresAt < DateTime.UtcNow)\n            {\n                _internalTokenCache = await GetToken(new Scope[] { Scope.BucketCreate, Scope.BucketRead, Scope.DataRead, Scope.DataWrite, Scope.DataCreate });\n            }\n            return _internalTokenCache;\n        }\n\n        private async Task<Token> GetToken(Scope[] scopes)\n        {\n            dynamic auth = await new TwoLeggedApi().AuthenticateAsync(_clientId, _clientSecret, "client_credentials", scopes);\n            return new Token\n            {\n                AccessToken = auth.access_token,\n                ExpiresAt = DateTime.UtcNow.AddSeconds(auth.expires_in)\n            };\n        }\n    }\n}\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"EnsureBucketExists")," method will simply try and request additional information\nabout a specific bucket, and if the response from Forge is ",(0,r.kt)("inlineCode",{parentName:"p"},"404 Not Found"),", it will\nattempt to create a new bucket with that name."),(0,r.kt)("h2",{id:"listing-models"},"Listing models"),(0,r.kt)("p",null,"Now we will update the ",(0,r.kt)("inlineCode",{parentName:"p"},"ForgeService")," class with a helper function that will\nlist all objects in the preconfigured bucket:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Models/ForgeService.cs"',title:'"Models/ForgeService.cs"'},'using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading.Tasks;\nusing Autodesk.Forge;\nusing Autodesk.Forge.Client;\nusing Autodesk.Forge.Model;\n\nnamespace simpleviewer\n{\n    public class Token\n    {\n        public string AccessToken { get; set; }\n        public DateTime ExpiresAt { get; set; }\n    }\n\n    public interface IForgeService\n    {\n        // highlight-start\n        Task<IEnumerable<dynamic>> GetObjects();\n        // highlight-end\n        Task<Token> GetAccessToken();\n    }\n\n    public class ForgeService : IForgeService\n    {\n        private readonly string _clientId;\n        private readonly string _clientSecret;\n        private readonly string _bucket;\n        private Token _internalTokenCache;\n        private Token _publicTokenCache;\n\n        public ForgeService(string clientId, string clientSecret, string bucket = null)\n        {\n            _clientId = clientId;\n            _clientSecret = clientSecret;\n            _bucket = string.IsNullOrEmpty(bucket) ? string.Format("{0}-basic-app", _clientId.ToLower()) : bucket;\n        }\n\n        // highlight-start\n        public async Task<IEnumerable<dynamic>> GetObjects()\n        {\n            const int PageSize = 64;\n            await EnsureBucketExists(_bucket);\n            var token = await GetInternalToken();\n            var api = new ObjectsApi();\n            api.Configuration.AccessToken = token.AccessToken;\n            var objects = new List<dynamic>();\n            dynamic response = await api.GetObjectsAsync(_bucket, PageSize);\n            foreach (KeyValuePair<string, dynamic> obj in new DynamicDictionaryItems(response.items))\n            {\n                objects.Add(new { name = obj.Value.objectKey, urn = Base64Encode(obj.Value.objectId) });\n            }\n            while ((response as DynamicDictionary).Dictionary.ContainsKey("next")) // This feels hacky... is there a better way?\n            {\n                var queryParams = Microsoft.AspNetCore.WebUtilities.QueryHelpers.ParseQuery(new Uri(response.next).Query);\n                response = await api.GetObjectsAsync(_bucket, PageSize, null, queryParams["startAt"]);\n                foreach (KeyValuePair<string, dynamic> obj in new DynamicDictionaryItems(response.items))\n                {\n                    objects.Add(new { name = obj.Value.objectKey, urn = Base64Encode(obj.Value.objectId) });\n                }\n            }\n            return objects;\n        }\n        // highlight-end\n\n        public async Task<Token> GetAccessToken()\n        {\n            return await GetPublicToken();\n        }\n\n        private async Task EnsureBucketExists(string bucketKey)\n        {\n            var token = await GetInternalToken();\n            var api = new BucketsApi();\n            api.Configuration.AccessToken = token.AccessToken;\n            try\n            {\n                await api.GetBucketDetailsAsync(bucketKey);\n            }\n            catch (ApiException e)\n            {\n                if (e.ErrorCode == 404)\n                {\n                    await api.CreateBucketAsync(new PostBucketsPayload(bucketKey, null, PostBucketsPayload.PolicyKeyEnum.Temporary));\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n        }\n\n        private async Task<Token> GetPublicToken()\n        {\n            if (_publicTokenCache == null || _publicTokenCache.ExpiresAt < DateTime.UtcNow)\n            {\n                _publicTokenCache = await GetToken(new Scope[] { Scope.ViewablesRead });\n            }\n            return _publicTokenCache;\n        }\n\n        private async Task<Token> GetInternalToken()\n        {\n            if (_internalTokenCache == null || _internalTokenCache.ExpiresAt < DateTime.UtcNow)\n            {\n                _internalTokenCache = await GetToken(new Scope[] { Scope.BucketCreate, Scope.BucketRead, Scope.DataRead, Scope.DataWrite, Scope.DataCreate });\n            }\n            return _internalTokenCache;\n        }\n\n        private async Task<Token> GetToken(Scope[] scopes)\n        {\n            dynamic auth = await new TwoLeggedApi().AuthenticateAsync(_clientId, _clientSecret, "client_credentials", scopes);\n            return new Token\n            {\n                AccessToken = auth.access_token,\n                ExpiresAt = DateTime.UtcNow.AddSeconds(auth.expires_in)\n            };\n        }\n\n        // highlight-start\n        private static string Base64Encode(string plainText)\n        {\n            var plainTextBytes = System.Text.Encoding.UTF8.GetBytes(plainText);\n            return System.Convert.ToBase64String(plainTextBytes).TrimEnd(\'=\');\n        }\n        // highlight-end\n    }\n}\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"GetObjects")," method pages through all objects in the bucket, and returns their name and URN\n(the base64-encoded ID that will later be used when communicating with the Model Derivative service)."),(0,r.kt)("h2",{id:"uploading-and-translating-models"},"Uploading and translating models"),(0,r.kt)("p",null,"Finally we will add helper methods to ",(0,r.kt)("inlineCode",{parentName:"p"},"ForgeService")," that will handle the uploading of a file\nto the Data Management service, and its translation into a format that can later be loaded into\nForge Viewer:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Models/ForgeService.cs"',title:'"Models/ForgeService.cs"'},'using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Threading.Tasks;\nusing Autodesk.Forge;\nusing Autodesk.Forge.Client;\nusing Autodesk.Forge.Model;\n\nnamespace simpleviewer\n{\n    public class Token\n    {\n        public string AccessToken { get; set; }\n        public DateTime ExpiresAt { get; set; }\n    }\n\n    public interface IForgeService\n    {\n        Task<IEnumerable<dynamic>> GetObjects();\n        Task<Token> GetAccessToken();\n        // highlight-start\n        Task<dynamic> UploadModel(string objectName, Stream content, long contentLength);\n        Task<dynamic> TranslateModel(string objectId, string rootFilename);\n        // highlight-end\n    }\n\n    public class ForgeService : IForgeService\n    {\n        private readonly string _clientId;\n        private readonly string _clientSecret;\n        private readonly string _bucket;\n        private Token _internalTokenCache;\n        private Token _publicTokenCache;\n\n        public ForgeService(string clientId, string clientSecret, string bucket = null)\n        {\n            _clientId = clientId;\n            _clientSecret = clientSecret;\n            _bucket = string.IsNullOrEmpty(bucket) ? string.Format("{0}-basic-app", _clientId.ToLower()) : bucket;\n        }\n\n        public async Task<IEnumerable<dynamic>> GetObjects()\n        {\n            const int PageSize = 64;\n            await EnsureBucketExists(_bucket);\n            var token = await GetInternalToken();\n            var api = new ObjectsApi();\n            api.Configuration.AccessToken = token.AccessToken;\n            var objects = new List<dynamic>();\n            dynamic response = await api.GetObjectsAsync(_bucket, PageSize);\n            foreach (KeyValuePair<string, dynamic> obj in new DynamicDictionaryItems(response.items))\n            {\n                objects.Add(new { name = obj.Value.objectKey, urn = Base64Encode(obj.Value.objectId) });\n            }\n            while ((response as DynamicDictionary).Dictionary.ContainsKey("next")) // This feels hacky... is there a better way?\n            {\n                var queryParams = Microsoft.AspNetCore.WebUtilities.QueryHelpers.ParseQuery(new Uri(response.next).Query);\n                response = await api.GetObjectsAsync(_bucket, PageSize, null, queryParams["startAt"]);\n                foreach (KeyValuePair<string, dynamic> obj in new DynamicDictionaryItems(response.items))\n                {\n                    objects.Add(new { name = obj.Value.objectKey, urn = Base64Encode(obj.Value.objectId) });\n                }\n            }\n            return objects;\n        }\n\n        // highlight-start\n        public async Task<dynamic> UploadModel(string objectName, Stream content, long contentLength)\n        {\n            await EnsureBucketExists(_bucket);\n            var token = await GetInternalToken();\n            var api = new ObjectsApi();\n            api.Configuration.AccessToken = token.AccessToken;\n            dynamic obj = await api.UploadObjectAsync(_bucket, objectName, (int)contentLength, content);\n            return obj;\n        }\n        // highlight-end\n\n        // highlight-start\n        public async Task<dynamic> TranslateModel(string objectId, string rootFilename)\n        {\n            var token = await GetInternalToken();\n            var api = new DerivativesApi();\n            api.Configuration.AccessToken = token.AccessToken;\n            var formats = new List<JobPayloadItem> {\n                new JobPayloadItem (JobPayloadItem.TypeEnum.Svf, new List<JobPayloadItem.ViewsEnum> { JobPayloadItem.ViewsEnum._2d, JobPayloadItem.ViewsEnum._2d })\n            };\n            var payload = new JobPayload(\n                new JobPayloadInput(Base64Encode(objectId)),\n                new JobPayloadOutput(formats)\n            );\n            if (!string.IsNullOrEmpty(rootFilename))\n            {\n                payload.Input.RootFilename = rootFilename;\n                payload.Input.CompressedUrn = true;\n            }\n            dynamic job = await api.TranslateAsync(payload);\n            return job;\n        }\n        // highlight-end\n\n        public async Task<Token> GetAccessToken()\n        {\n            return await GetPublicToken();\n        }\n\n        private async Task EnsureBucketExists(string bucketKey)\n        {\n            var token = await GetInternalToken();\n            var api = new BucketsApi();\n            api.Configuration.AccessToken = token.AccessToken;\n            try\n            {\n                await api.GetBucketDetailsAsync(bucketKey);\n            }\n            catch (ApiException e)\n            {\n                if (e.ErrorCode == 404)\n                {\n                    await api.CreateBucketAsync(new PostBucketsPayload(bucketKey, null, PostBucketsPayload.PolicyKeyEnum.Temporary));\n                }\n                else\n                {\n                    throw e;\n                }\n            }\n        }\n\n        private async Task<Token> GetPublicToken()\n        {\n            if (_publicTokenCache == null || _publicTokenCache.ExpiresAt < DateTime.UtcNow)\n            {\n                _publicTokenCache = await GetToken(new Scope[] { Scope.ViewablesRead });\n            }\n            return _publicTokenCache;\n        }\n\n        private async Task<Token> GetInternalToken()\n        {\n            if (_internalTokenCache == null || _internalTokenCache.ExpiresAt < DateTime.UtcNow)\n            {\n                _internalTokenCache = await GetToken(new Scope[] { Scope.BucketCreate, Scope.BucketRead, Scope.DataRead, Scope.DataWrite, Scope.DataCreate });\n            }\n            return _internalTokenCache;\n        }\n\n        private async Task<Token> GetToken(Scope[] scopes)\n        {\n            dynamic auth = await new TwoLeggedApi().AuthenticateAsync(_clientId, _clientSecret, "client_credentials", scopes);\n            return new Token\n            {\n                AccessToken = auth.access_token,\n                ExpiresAt = DateTime.UtcNow.AddSeconds(auth.expires_in)\n            };\n        }\n\n        private static string Base64Encode(string plainText)\n        {\n            var plainTextBytes = System.Text.Encoding.UTF8.GetBytes(plainText);\n            return System.Convert.ToBase64String(plainTextBytes).TrimEnd(\'=\');\n        }\n    }\n}\n')),(0,r.kt)("h2",{id:"server-endpoints"},"Server endpoints"),(0,r.kt)("p",null,"Finally, let's expose this new functionality to the client-side code through another ASP.NET\ncontroller. Create a ",(0,r.kt)("inlineCode",{parentName:"p"},"ModelsController.cs")," file under the ",(0,r.kt)("inlineCode",{parentName:"p"},"Controllers")," subfolder\nwith the following content:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-csharp",metastring:'title="Controllers/ModelsController.cs"',title:'"Controllers/ModelsController.cs"'},'using System.IO;\nusing System.Threading.Tasks;\nusing Microsoft.AspNetCore.Http;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Extensions.Logging;\nusing Newtonsoft.Json;\n\nnamespace simpleviewer\n{\n    [ApiController]\n    [Route("api/[controller]")]\n    public class ModelsController : ControllerBase\n    {\n        private readonly ILogger<ModelsController> _logger;\n        private readonly IForgeService _forgeService;\n\n        public ModelsController(ILogger<ModelsController> logger, IForgeService forgeService)\n        {\n            _logger = logger;\n            _forgeService = forgeService;\n        }\n\n        [HttpGet()]\n        public async Task<ActionResult<string>> GetModels()\n        {\n            var objects = await _forgeService.GetObjects();\n            return JsonConvert.SerializeObject(objects);\n        }\n\n        public class UploadModelForm\n        {\n            [FromForm(Name = "model-zip-entrypoint")]\n            public string Entrypoint { get; set; }\n\n            [FromForm(Name = "model-file")]\n            public IFormFile File { get; set; }\n        }\n\n        [HttpPost()]\n        public async Task UploadAndTranslateModel([FromForm] UploadModelForm form)\n        {\n            // For some reason we cannot use the incoming stream directly...\n            // so let\'s save the model into a local temp file first\n            var tmpPath = Path.GetTempFileName();\n            using (var stream = new FileStream(tmpPath, FileMode.OpenOrCreate))\n            {\n                await form.File.CopyToAsync(stream);\n            }\n            using (var stream = System.IO.File.OpenRead(tmpPath))\n            {\n                dynamic obj = await _forgeService.UploadModel(form.File.FileName, stream, form.File.Length);\n                await _forgeService.TranslateModel(obj.objectId, form.Entrypoint);\n            }\n            System.IO.File.Delete(tmpPath);\n        }\n    }\n}\n')),(0,r.kt)("p",null,"The controller will handle two types of requests - a ",(0,r.kt)("inlineCode",{parentName:"p"},"GET /api/models")," request when the client wants\nto get the list of all available models for viewing, and a ",(0,r.kt)("inlineCode",{parentName:"p"},"POST /api/models")," request when the client\nwants to upload a new model and translate it for viewing."),(0,r.kt)("h2",{id:"try-it-out"},"Try it out"),(0,r.kt)("p",null,"Time to test our improved server application. This time, apart from setting the Forge application\ncredentials, you can also include the name of the Data Management bucket you want to use via\nthe optional ",(0,r.kt)("inlineCode",{parentName:"p"},"FORGE_BUCKET")," environment variable:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"export FORGE_CLIENT_ID=your-own-forge-client-id\nexport FORGE_CLIENT_SECRET=your-own-forge-client-secret\nexport FORGE_BUCKET=your-custom-bucket-name\ndotnet run\n")),(0,r.kt)("p",null,"If the bucket name is ",(0,r.kt)("em",{parentName:"p"},"not")," provided, the ",(0,r.kt)("inlineCode",{parentName:"p"},"ForgeService")," class will generate one by appending ",(0,r.kt)("inlineCode",{parentName:"p"},"-basic-app"),"\nto your Forge client ID."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Note that the Data Management service requires bucket names to be ",(0,r.kt)("strong",{parentName:"p"},"globally unique"),",\nand attempts to create a bucket with an already used name will fail with ",(0,r.kt)("inlineCode",{parentName:"p"},"409 Conflict"),".\nSee the ",(0,r.kt)("a",{parentName:"p",href:"https://forge.autodesk.com/en/docs/data/v2/reference/http/buckets-POST"},"documentation"),"\nfor more details.")),(0,r.kt)("p",null,"When you navigate to https://localhost:5001/api/models in the browser, the server should respond with\na JSON list with names and URNs of all objects available in your configured bucket."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"TODO: screenshot")))}d.isMDXComponent=!0}}]);